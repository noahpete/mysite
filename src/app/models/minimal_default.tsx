/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useRef, useEffect, useState } from "react";
import { useGLTF, Float } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { GLTF } from "three-stdlib";
import gsap from "gsap";

type GLTFResult = GLTF & {
  nodes: {
    Floor: THREE.Mesh;
    Table: THREE.Mesh;
    Chair: THREE.Mesh;
    Chair_1: THREE.Mesh;
    Statue_1: THREE.Mesh;
    Statue_2: THREE.Mesh;
  };
  materials: {
    M_Ceramic_Tile_Checker: THREE.MeshStandardMaterial;
    M_TableRound: THREE.MeshStandardMaterial;
    M_Chair: THREE.MeshStandardMaterial;
    M_StatueGlass_Statue: THREE.MeshStandardMaterial;
    M_Metal_Burnished_Steel: THREE.MeshStandardMaterial;
  };
};

export default function MinimalDefault(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("/minimial_default.glb") as GLTFResult;
  const [mousePos, setMousePosition] = useState({ x: 0, y: 0 });
  const [prevPos, setPrevPosition] = useState({ x: 0, y: 0 });
  const meshRef = useRef(null);
  const ANIMATION_RATE = 0.3;

  useEffect(() => {
    const handleMouseMove = (event: any) => {
      const { clientX, clientY } = event;
      setPrevPosition(mousePos);
      setMousePosition({ x: clientX, y: clientY });
    };

    window.addEventListener("mousemove", handleMouseMove);

    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
    };
  }, []);

  useFrame(({ camera }) => {
    // Adapted from https://codepen.io/kylewetton/pen/WNNeyWJ?editors=0010
    const degreeLimit = 30;
    let x = mousePos.x;
    let y = mousePos.y;
    let dx = 0,
      dy = 0,
      xdiff,
      xPercentage,
      ydiff,
      yPercentage;
    let w = { x: window.innerWidth, y: window.innerHeight };
    if (x <= w.x / 2) {
      xdiff = w.x / 2 - x;
      xPercentage = (xdiff / (w.x / 2)) * 100;
      dx = ((degreeLimit * xPercentage) / 100) * -1;
    }
    if (x >= w.x / 2) {
      xdiff = x - w.x / 2;
      xPercentage = (xdiff / (w.x / 2)) * 100;
      dx = (degreeLimit * xPercentage) / 100;
    }
    if (y <= w.y / 2) {
      ydiff = w.y / 2 - y;
      yPercentage = (ydiff / (w.y / 2)) * 100;
      dy = ((degreeLimit * 0.5 * yPercentage) / 100) * -1;
    }
    if (y >= w.y / 2) {
      ydiff = y - w.y / 2;
      yPercentage = (ydiff / (w.y / 2)) * 100;
      dy = (degreeLimit * yPercentage) / 100;
    }

    const ROTATION_COEFF = 0.0025;
    meshRef.current.rotation.y = dx * ROTATION_COEFF;
    meshRef.current.rotation.x = dy * ROTATION_COEFF;
  });

  return (
    <group {...props} dispose={null} ref={meshRef}>
      {/* <mesh
        castShadow
        receiveShadow
        geometry={nodes.Floor.geometry}
        material={materials.M_Ceramic_Tile_Checker}
        position={[-4, 0.32, -2]}
        scale={[1, 2, 1]}
      /> */}

      <Float>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Chair.geometry}
          material={materials.M_Chair}
          position={[-2.1, 0.32, 1.05]}
          rotation={[0, 0.48, 0]}
        />
      </Float>
      <Float>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Chair_1.geometry}
          material={materials.M_Chair}
          position={[-2.15, 0.32, -1.2]}
          rotation={[0, -1.113, 0]}
        />
      </Float>
      <Float
        speed={0.5 * ANIMATION_RATE}
        rotationIntensity={4 * ANIMATION_RATE}
        floatIntensity={0.5 * ANIMATION_RATE}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Table.geometry}
          material={materials.M_TableRound}
          position={[-1.8, 0.32, 0]}
          rotation={[Math.PI, 0.873, -Math.PI]}
        />
        <Float>
          <group
            position={[-1.81, 1.02, 0.01]}
            rotation={[Math.PI, 0.175, -Math.PI]}
            scale={0.5}
          >
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Statue_1.geometry}
              material={materials.M_StatueGlass_Statue}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.Statue_2.geometry}
              material={materials.M_Metal_Burnished_Steel}
            />
          </group>
        </Float>
      </Float>
    </group>
  );
}

useGLTF.preload("/minimial_default.glb");
